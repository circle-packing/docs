% ---------- Titelblad Masterproef Faculteit Wetenschappen -----------
% Dit document is opgesteld voor compilatie met pdflatex.  Indien je
% wilt compileren met latex naar dvi/ps, dien je de figuren naar
% (e)ps-formaat om te zetten.
%                           -- december 2012
% -------------------------------------------------------------------
\RequirePackage{fix-cm}
\documentclass[12pt,a4paper,oneside]{book}

% --------------------- In te laden pakketten -----------------------
% Deze kan je eventueel toevoegen aan de pakketten die je al inlaadt
% als je dit titelblad integreert met de rest van thesis.
% -------------------------------------------------------------------
\usepackage{graphicx,xcolor,textpos}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{helvet}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[hypcap]{caption}
\usepackage{color}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{pgfplotstable}
\usepackage{needspace}
\usepackage[toc,page]{appendix}

% -------------------- Pagina-instellingen --------------------------
% Indien je deze wijzigt, zal het titelblad ook wijzigen.  Dit dien je
% dan manueel aan te passen.
% --------------------------------------------------------------------
\topmargin -10mm
\textwidth 160truemm
\textheight 240truemm
\oddsidemargin 0mm
\evensidemargin 0mm

% ------------------- textpos-instellingen ---------------------------
% Enkele andere instellingen voor het voorblad.
% --------------------------------------------------------------------
\definecolor{green}{RGB}{172,196,0}
\definecolor{bluetitle}{RGB}{29,141,176}
\definecolor{blueaff}{RGB}{0,0,128}
\definecolor{blueline}{RGB}{82,189,236}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\setlength{\TPHorizModule}{1mm}
\setlength{\TPVertModule}{1mm}

% Eigen instellingen
\input{packoTables}
\graphicspath{{images/}}
\renewcommand{\contentsname}{Inhoud}
\renewcommand{\listfigurename}{Lijst van figuren}
\renewcommand{\listtablename}{Lijst van tabellen}
\renewcommand{\chaptername}{Hoofdstuk}
\renewcommand{\chapterautorefname}{hoofdstuk}
\renewcommand{\sectionautorefname}{sectie}
\renewcommand{\subsectionautorefname}{sectie}
\renewcommand{\figureautorefname}{figuur}
\renewcommand{\tableautorefname}{tabel}
\newcommand{\lstnumberautorefname}{lijn}
\newcommand*{\Appendixautorefname}{bijlage}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
  escapechar=|
}

\begin{document}

% ---------------------- Voorblad ------------------------------------
% Vergeet niet de tekst aan te passen:
% - Titel en, indien van toepassing, ondertitel
%          voor eventuele formules in de titel of ondertitel
%          gebruik je  \form{$...$}
% - Je naam
% - Je (co)promotor, begeleider (indien van toepassing)
% - Je opleiding
% - Het academiejaar
% --------------------------------------------------------------------
\thispagestyle{empty}
\newcommand{\form}[1]{\scalebox{1.087}{\boldmath{#1}}}
\sffamily
%
\begin{textblock}{191}(-24,-11)
\colorbox{green}{\hspace{123mm}\ \parbox[c][18truemm]{68mm}{\textcolor{white}{FACULTEIT WETENSCHAPPEN}}}
\end{textblock}
%
\begin{textblock}{70}(-18,-19)
\textblockcolour{}
\includegraphics*[height=19.8truemm]{LogoKULeuven.png}
\end{textblock}
%
\begin{textblock}{79}(50,50)
\centerline{\includegraphics*[height=10.0truecm]{voorbladpacking.png}}
%De achtergrond kan wit blijven of je kan een afbeelding invoegen (maximum hoogte 10 cm, breedte variabel, denk aan auteursrechten\ldots). GEEN logo's (je kan binnenin de masterproef logo's gebruiken, maar niet op de voor- of achterpagina).
\end{textblock}
%
\begin{textblock}{160}(-6,63)
\textblockcolour{}
\vspace{-\parskip}
\flushleft
\fontsize{40}{42}\selectfont \textcolor{bluetitle}{Een nieuwe constructieve heuristic voor het plaatsen van cirkels in een cirkel}\\[1.5mm]
\fontsize{20}{22}\selectfont Gebaseerd op een \textit{best-fit} methodiek
\end{textblock}
%
\begin{textblock}{160}(8,153)
\textblockcolour{}
\vspace{-\parskip}
\flushright
\fontsize{14}{16}\selectfont \textbf{Pablo BOLLANSÉE}
\end{textblock}
%
\begin{textblock}{70}(-6,191)
\textblockcolour{}
\vspace{-\parskip}
\flushleft
Promotor: Prof. P. De Causmaecker \\[-2pt]
\textcolor{blueaff}{Affiliatie \textsl{(facultatief)}}\\[5pt]
Co-promotor: \textsl{(facultatief)}\\[-2pt]
\textcolor{blueaff}{Affiliatie \textsl{(facultatief)}}\\[5pt]
Begeleider: \textsl{(facultatief)}\\[-2pt]
\textcolor{blueaff}{Affiliatie \textsl{(facultatief)}}\\
\end{textblock}
%
\begin{textblock}{160}(8,191)
\textblockcolour{}
\vspace{-\parskip}
\flushright
Proefschrift ingediend tot het\\[4.5pt]
behalen van de graad van\\[4.5pt]
Master of Science in de\\[4.5pt]
toegepaste informatica\\
\end{textblock}
%
\begin{textblock}{160}(8,232)
\textblockcolour{}
\vspace{-\parskip}
\flushright
Academiejaar 2015-2016
\end{textblock}
%
\begin{textblock}{191}(-24,248)
{\color{blueline}\rule{550pt}{5.5pt}}
\end{textblock}
%
\vfill

\newpage
\thispagestyle{empty}
\begin{textblock}{160}(0,185)
© Copyright by KU Leuven

Zonder voorafgaande schriftelijke toestemming van zowel de promotor(en) als de auteur(s) is overnemen, kopiëren, gebruiken of realiseren van deze uitgave of gedeelten ervan verboden. Voor aanvragen tot of informatie i.v.m. het overnemen en/of gebruik en/of realisatie van gedeelten uit deze publicatie, wendt u tot de KU Leuven, Faculteit Wetenschappen, Geel Huis, Kasteelpark Arenberg 11 bus 2100, 3001 Leuven (Heverlee), Telefoon +32 16 32 14 01.

Voorafgaande schriftelijke toestemming van de promotor(en) is eveneens vereist voor het aanwenden van de in dit afstudeerwerk beschreven (originele) methoden, producten, schakelingen en programma’s voor industrieel of commercieel nut en voor de inzending van deze publicatie ter deelname aan wetenschappelijke prijzen of wedstrijden.
\end{textblock}

\newpage

% Als je het titelblad wil integreren met de rest van je thesis,
% kan je hieronder verder.
% ----------------------- Eerste pagina's -------------------------
% Hier kan je inhoudsopgave, voorwoord en dergelijke kwijt.
% -----------------------------------------------------------------
\rmfamily
\setcounter{page}{0}
\pagenumbering{roman}

\newpage

\chapter*{Voorwoord}
\addcontentsline{toc}{chapter}{Voorwoord}

Het circle-packing probleem bestaat er uit om een aantal cirkels, met gekende radii, in een zo klein mogelijke container te plaatsen.
De vorm van deze container kan verschillen, meestal is het een driehoek, rechthoek of cirkel.
In deze thesis stel ik een nieuwe \textit{best-fit} gebaseerde heuristiek voor voor het plaatsen van cirkels in een cirkel.
Het is een constructieve heuristiek waarin stapsgewijs telkens de best-passende cirkel geplaatst zal worden.
Alle code is beschikbaar op GitHub \cite{circle-packing-github}

Wiskundig is dit een relatief eenvoudig probleem om voor te stellen, maar computationeel is het zeer zwaar om exact op te lossen.
Bestaande pogingen om dit probleem op te lossen vragen zeer veel tijd om het te berekenen.
In deze thesis stel ik een nieuwe heuristiek voor die het mogelijk maakt zéér snel oplossingen te genereren.

Ik wil hierbij Patrick De Causmaeker bedanken voor alle hulp en ondersteuning bij het ontwerpen van deze heuristiek en verwezenlijken van dit werk.
Ook wil ik Jim Bollansée, Marie Julia Bollansée en Pieter Van de Walle bedanken voor hun hulp bij het schrijven van deze tekst.

%  In het voorwoord wordt de algemene doelstelling van het werk samengevat
%  in enkele regels en worden personen, diensten of firma’s bedankt voor hun
%  medewerking bij het tot stand komen van het werk.
%  De naam van firma’s en personen uit deze firma’s mogen slechts worden vermeld
%  mits hun uitdrukkelijke toelating én na overleg met de supervisor(en)! Steeds
%  wordt de supervisor(en) vermeld, de verantwoordelijke en eventueel de personen
%  die rechtstreeks geholpen hebben bv. door het ter beschikking stelling van
%  meetresultaten, faciliteiten. Ook de instantie die eventueel een doctoraatsbeurs
%  heeft toegekend wordt bedankt (bv. FWO, IWT, . . . ).

\newpage

\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

TODO

%  In een beknopte tekst van maximum 2 pagina’s worden de belangrijkste
%  doelstellingen en besluiten geformuleerd, zowel in het Nederlands als in het
%  Engels. Zulke samenvattingen kunnen worden gebruikt in wetenschappelijke
%  verslagen van het departement of de faculteit. Het Engels moet vlekkeloos zijn.

\newpage

\tableofcontents
\listoffigures
\addcontentsline{toc}{chapter}{Lijst van figuren}
\listoftables
\addcontentsline{toc}{chapter}{Lijst van tabellen}

\newpage

% ----------------------- Eigenlijke thesis -----------------------
% Vanaf de inleiding/het eerste hoofdstuk.
% -----------------------------------------------------------------
\setcounter{page}{0}
\pagenumbering{arabic}

\chapter{Inleiding}

In deze thesis stel ik een nieuwe \textit{best-fit} gebaseerde heuristiek voor om het \textit{circle-packing} probleem.
De heuristiek is specifiek ontworpen voor het sub-probleem van het plaatsen van cirkels in een cirkel.
Het \textit{circle-packing} probleem bestaat uit het plaatsen van $n$ cirkels in een zo klein mogelijke cirkelvormige \textit{container}.
Het is de bedoeling om voor de gegeven cirkels de coordinaten van de middelpunten te vinden zodat de cirkels niet overlappen en de radius van de omcirkel zo klein mogelijk is.

Circle-packing is zowel theoretisch als praktisch een zeer interessant probleem.
Het kan gebruikt worden om verschillende \textit{real-world} problemen op te lossen, zoals het plaatsen van zendmasten, stokage van cilindrische voorwerpen, en het combineren van verschillende kabels. //TODO voeg referenties toe voor deze gebruiken

Mathematisch is het probleem redelijk eenvoudig als een optimalisatieprobleem te omschrijven:

\begin{equation*}
\begin{aligned}
& \text{minimaliseer}
& & r \\
& \text{onderhevig aan}
& & x_i^2 + y_i^2 \leq (r-r_i)^2, 
& & &i = {1,...,n}\\
&&& (x_i - x_j)^2 + (y_i - y_j)^2 \geq (r_i + r_j)^2,
& & &i \neq j
\end{aligned}
\end{equation*}

Hierin is $r_i$ de radius, en $(x_i,y_i)$ de coördinaten van het centrum van cirkel $i$.
Hierbij wordt verondersteld dat de omcirkel het nulpunt als middelpunt heeft.
De eerste formule verzekert dat de cirkels in de omcirkel liggen, en de tweede dat ze elkaar niet overlappen.
Wanneer alle cirkels dezelfde grootte hebben, wordt meestal $r_i$ gelijk aan $1$ genomen.
Het circle-packing probleem voor andere containers heeft gelijkaardige, relatief eenvoudige, wiskundige omschrijvingen.

Hoewel dit wiskundig eenvoudig te omschrijven is, blijft het toch een zeer moeilijk probleem om exact op te lossen.
Er is reeds veel onderzoek gebeurd naar het oplossen van het circle-packing probleem voor zowel cirkels van gelijke gootte, als voor cirkels van verschillende grootte.
In \cite{graham1996repeated} en \cite{lubachevsky1997curved} probeert men vaste patronen te vinden die een optimale packing van cirkels met gelijke grootte geeft.
In \cite{graham1998dense} en \cite{wang2002improved} worden fysisch geïnspireerde simulaties gebruikt om packing te bekomen.
In \cite{george1995packing} worden verschillende meta-heuristieken, waaronder een genetisch algoritme, uitgeprobeerd en vergeleken.
Zij ondervinden dat dit genetisch algoritme, als ook een quasi-random techniek, in vergelijking met de andere uitgeprobeerde meta-heuristieken, de beste resultaten geven.
In \cite{hifi2004approximate} en \cite{hifi2004simulated} worden respectievelijk een genetisch en een simulated-annealing algoritme voorgesteld.
Een recentere poging is het Monotonic Basin Hopping algoritme voorgesteld in \cite{grosso2010}.
Hierin beschrijven de auteurs dat er te veel lokale optima zijn voor een eenvoudige multi-start behandeling, en stellen een variant voor waarin ze op een slimme manier de begin punten proberen genereren.
Ook meer recent zijn \cite{jors2011} (2011), \cite{ye2013iterated} (2013) en \cite{zeng2016iterated} (2016).
Hierin worden de combinatorische eigenschappen van circle-packing in combinatie met een zoekmethode zoals \textit{tabu-search} en \textit{iterated local search} gebruikt om een goede volgorde te vinden waarin de cirkels geplaatst worden.
In \cite{jors2011} plaatsen ze zo één voor één elke cirkel en berekend een \textit{non-linear optimizer} hiervoor telkens een lokaal extremum voor de \textit{packing}.

Constructieve algoritmen voor het oplossen van circle-packings zijn veel minder onderzocht.
Een constructief algoritme is een algoritme dat, beginnende van een zekere begin situatie, stapsgewijs de oplossing uitbreidt tot een volledige oplossing bekomen is.
Eén van de weinige constructieve methoden wordt beschreven in \cite{akeb2006basic}, waar ze een alternatieve vorm van het \textit{circle-packing} probleem oplossen: de grootte van de container ligt vast, en er moeten zo veel mogelijk cirkels van gelijke grootte in de container geplaatst worden.
In \cite{hifi2004approximate} wordt er een aanpassing gedaan op de klassieke bottom-left-first heuristiek, voor het plaatsen van rechthoeken.

Hoewel veel van deze oplossingen zeer goede packings maken, en regelmatig hun voorgangers verbeteren, vragen ze veel rekentijd en beperken ze zich tot een klein aantal cirkels.
Voor slechts tientallen cirkels kan de nodige rekentijd oplopen tot tientallen uren.
In deze thesis stel ik een nieuw constructieve heuristiek voor om het circle-packing probleem op te lossen.
Deze nieuwe heuristiek laat toe om packings te maken in een fractie van de tijd die andere algoritmen daarvoor nodig hebben.
Ook is het mogelijk om veel grotere aantallen cirkels te plaatsen.
De omcirkel van packings verkregen met deze nieuwe heuristiek is echter iets groter dan deze verkregen in voorgenoemd onderzoek.
Deze uitbreiding van de omcirkel blijft echter beperkt en laat toe de packings in slecht enkele ogenblikken te maken, waar anderen uren rekentijd vragen.

De heuristiek voorgesteld in deze thesis is een best-fit heuristiek gebaseerd op een oplossing voor het Orthogonal Stock-Cutting Problem voorgesteld in \cite{burke2004new}.
In dit probleem worden balken geplaatst in een container met een vaste breedte, zodat de hoogte zo klein mogelijk blijft.
Zij gebruiken het verschil tussen de breedte van een balk en een gat in de packing als heuristiek voor de \textit{beste} positie.
Hun heuristiek kiest dus de volgende balk om te plaatsen uit een lijst, en deze plaatst op de \textit{beste} positie.
Dit is in tegenstelling tot cirkels plaatsen in een vooraf bepaalde volgorde zoals in \cite{grosso2010} en \cite{jors2011}.
Op een gelijkaardige manier kiest mijn algoritme de volgende cirkel die best past in de huidige packing.

In \autoref{chap:algoritme} bespreek ik hoe de heuristiek opgebouwd is.
Ik beschrijf de twee basisconcepten voor mijn best-fit heuristiek, \textit{holes} en de \textit{shell}, in detail.
Ik bespreek hoe deze werken, en op welke manier gekozen wordt welke cirkel best past in de packing.
Hierbij haal ik ook de implementatie aan om deze concepten te verduidelijken.
In \autoref{chap:resultaten} worden de verkregen resultaten besproken.
Hier vergelijk ik de packings met de best gekende resultaten zoals gerapporteerd op de Packomania website (\cite{packomania}).
De Packomania website verzameld alle best gekende oplossingen voor verschillende circle-packing problemen.
Ik vergelijk de omtrek van de verkregen omcirkel en de nodige tijd om de packing te berekenen van mijn eigen heuristiek met de best gekende oplossingen op de Packomania website.
Ook toon ik resultaten voor packings voor veel meer cirkels dan getoond op de Packomania website.
In \autoref{chap:opmerkingen-en-verder-werk} bespreek ik mogelijke verbeteringen, overblijvende problemen in de heuristiek en ideeën voor verdere uitbreidingen en onderzoek.
Ook geef ik enkele bedenkingen over implementatie en conceptuele details van de heuristiek zoals hij nu is.
In \autoref{chap:handleiding-visualisaties} wordt kort verduidelijkt hoe de visualisaties te interpreteren die doorheen deze thesis gebruikt worden.
Maar eerst worden enkele termen die gebruikt worden in de verdere tekst, sommige uniek voor voor deze heuristiek, en definities gegeven in \autoref{chap:definities}.

// TODO: Vraag voor Patrick: Is het nodig sommige termen te verduidelijken? De termen: NP-Moeilijk, meta-heuristiek, genetisch algoritme, quasi-random techniek, simulated-annealing, tabu-search, bottom-left-first heuristiek -> Ja. TODO
% TODO: Vraag voor Patrick: Is het nodig de aangehaalde papers verder te verduidelijk? Of zijn de zeer korte besprekingen zoals ze nu zijn genoeg? -> Korte zijn genoeg

\chapter{Definities en termen} \label{chap:definities}

\textbf{Cirkel} In de literatuur rond \textit{circle-packing} en deze thesis wordt het woord "cirkel" of "circle" gebruikt, maar eigenlijk zou het correcter zijn om "schijf" te gebruiken.
Er is dus ook een overlap tussen cirkels wanneer een cirkel volledig omringd is door een andere.
Voor twee cirkels met radii $r_a, r_b$ en coordinaten  $(x_a,y_a), (x_b,y_b)$ is er een overlap wanneer $r_a + r_b > \sqrt{(x_a-x_b)^2 + (y_a-y_b)^2}$. 

\textbf{Packing} of \textbf{Plaatsing} Is een collectie cirkels met elks een toegewezen positie. Een packing is correct wanneer er geen overlap is tussen de cirkels in de packing.

\textbf{Holes} Is één van de concepten uniek aan deze heuristiek. Op een \textit{high-level} niveau is dit een plek tussen drie cirkels waar nog een andere cirkel kan geplaatst worden. Dit wordt in diep detail uitgelegd in \autoref{sec:holes}.

\textbf{Shell} Is het tweede concept uniek aan deze heuristiek. Dit is, op \textit{high-level} niveau, de collectie cirkels die aan de buitenkant van een packing liggen. Dit wordt verder verduidelijkt in \autoref{sec:shell}.

\chapter{Handleiding voor het lezen van de visualisaties} \label{chap:handleiding-visualisaties}

Doorheen deze thesis zal ik gebruik maken van visualisaties gegenereerd door de java implementatie van het algoritme.
Dit om de concepten grafisch te verduidelijken.
Twee voorbeelden van zulke visualisaties zijn \autoref{fig:handleiding-visualisatie-1} en \autoref{fig:handleiding-visualisatie-2}.

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{handleiding-visualisatie-1.png}
  \caption{Voorbeeld visualisatie met drie duidelijke holes} \label{fig:handleiding-visualisatie-1}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{handleiding-visualisatie-2.png}
  \caption{Voorbeeld visualisatie met grote shell} \label{fig:handleiding-visualisatie-2}
\end{figure}

Deze figuren kan u op de volgende manier interpreteren:

\begin{itemize}  
\item De \textbf{reeds geplaatste cirkels} worden getoond als \textbf{licht blauwe cirkels}.
\item De \textbf{shell} is een \textbf{gele lijn} aan de buitenste rand van de packing. Deze verbind de middelpunten van de cirkels op de shell.
\item De kleine \textbf{groene bolletjes} op de shell geven de posities aan waarop mogelijk een cirkel geplaatst zal worden.
\item \textbf{Holes} worden getoond als \textbf{rode driehoeken}. De hoekpunten liggen dicht bij de middelpunten van de drie cirkels die het gat definiëren.
\item De \textbf{omcirkel} van de huidige packing wordt getoond als een \textbf{groene cirkel}.
\end{itemize}

Op \autoref{fig:handleiding-visualisatie-1} is zijn er duidelijk drie holes te zien.
Elk van de drie holes word gedefinieerd door de centrale cirkel en twee van de buitenste cirkels.
Ook is er een kleine shell te zien, die bestaat uit de buitenste drie cirkels.
In \autoref{fig:handleiding-visualisatie-2} wordt een verder gevorderde packing getoond waarop één hole te zien is, en een veel grotere shell.
Op beide figuren kan je ook de omcirkel zien.

\chapter{Algoritme} \label{chap:algoritme}

In dit hoofdstuk bespreek ik de werking van de heuristiek.
Eerst geef ik een korte beschrijving van het basis idee van het algoritme, gevolgd door de structuur van de code.
Vervolgens leg ik stelselmatig de volledige werking uit, alle veronderstellingen die gemaakt worden en implementatie details waar nodig.
De volledige implementatie is beschikbaar op GitHub \cite{circle-packing-github} en is gebeurd in Java.

Om het algoritme zeer snel te maken worden enkele veronderstellingen gemaakt omtrent de nodige overlap checks bij elke stap.
Deze veronderstellingen zijn niet theoretisch bewezen, maar wel empirisch getest.
Voor de meeste verdelingen van cirkels lijken ze goed stand te houden, maar er zijn nog enkele \textit{edge-cases} waarin er toch nog fouten gebeuren.
Deze problemen worden besproken in \autoref{chap:opmerkingen-en-verder-werk} en de snelheid en kwaliteit van de oplossingen wordt verder besproken in \autoref{chap:resultaten}.

\section{Basis idee}

Het basis idee van de heuristiek is om stelselmatig een packing op te bouwen, door telkens cirkels te zoeken die het best passen.
Bij elke stap wordt telkens eerst een plek gekozen wordt om een cirkel te plaatsen (in een hole, of op de shell, later hier meer over).
Hier wordt dan de best-passende cirkel geplaatst.
Eenmaal een cirkel geplaatst is wordt deze nooit meer verplaatst.
Dit laat toe om intelligente structuren op te bouwen en deze op een zeer efficiënte manier te gebruiken.

Het algoritme bouwt dus cirkel per cirkel een packing op.
Dit door in elke stap een positie te kiezen, en hierin een cirkel te proberen plaatsen.
Indien er geen cirkel geplaatst kan worden wordt de interne structuur van het probleem vernieuwd om deze nieuwe informatie te reflecteren.
Dit gebeurt op verschillende manieren voor de holes en de shell.
Meer hierover vindt u terug in \autoref{sec:holes} en \autoref{sec:shell}.
Als er wel een cirkel geplaatst kan worden dan wordt deze uit de lijst van nog-te-plaatsen cirkels verwijderd, en krijgt deze een permanente positie daar.
Dit geeft ook aanleiding tot aanpassen van de holes en/of shell.
Hierdoor wordt er een nieuwe tussentijdse packing gemaakt.
Deze wordt dan door gegeven naar de volgende stap, waarin het algoritme opnieuw zal proberen een cirkel te plaatsen.
Op deze manier word een volledige packing opgebouwd voor alle cirkels.

\section{Structuur}

De implementatie van het algoritme bevat enkele belangrijke (programmeer-)klassen die regelmatig zullen terug komen in de verdere uit, vooral in code fragmenten:

\begin{itemize} 
\item Cirkel (Circle)
\item Vector2
\item Locatie (Location)
\item Probleem (Problem)
\item Oplossing (Solution)
\item Oplosser (Solver)
\item Gat (Hole)
\item Schil (Shell)
\end{itemize}

Een $circle$ is voor de hand liggend. Deze heeft een radius, maar geen positie.

$Vector2$ is een 2D positie. Deze bevat een x en y coördinaat.

Een $location$ of locatie is de combinatie van een cirkel met mijn positie. Deze bevat dus een referentie naar een $circle$ en een $vector2$.

Een $problem$ of probleem is een lijst van cirkels.
Deze hebben nog geen positie, en worden gesorteerd van groot naar klein.
Dit is wat de $solver$ als input krijgt.

Een $solution$ of oplossing is een lijst van cirkels met hun positie.
Dit kan een tussen oplossing zijn, waar nog niet voor alle cirkels uit een probleem een positie gevonden is.
Ook geeft dit geen garanties van correctheid, er kan dus bijvoorbeeld overlap zijn, maar voorziet functionaliteit om dit na te gaan.
Dit is wat de solver als output geeft.
Een correcte solver geeft natuurlijk wel altijd goede oplossingen.

Een $solver$ of oplosser is het object dat een packing zoekt voor een gegeven probleem.
Dit is dus het belangrijkste deel van de code, en hier is de nieuwe heuristiek geïmplementeerd.
De best-fit solver, zoals beschreven in deze thesis, doet dit stap voor stap.
In elke stap wordt er één cirkel geplaats op zijn finale positie, dit aan de hand van enkele keuzes die verder in dit hoofdstuk toegelicht zullen worden.

$Hole$ en $shell$ worden verder uitgelegd in respectievelijk \autoref{sec:holes} en \autoref{sec:shell}.

\section{Structuur van de solver}

Zoals hierboven gezegd is de solver het hart van de implementatie.
Deze maakt effectief een packing voor een gegeven probleem.
De solver bevat een lijst van \textit{holes} en de \textit{shell}.
Het bevat ook een lijst van de nog te plaatsen cirkels, en een tussen-oplossing met de cirkels die reeds een plaats gekregen hebben.
Ook heeft hij interne omcirkel voor deze oplossing.
Een oplossing kan zelf ook een omcirkel berekenen, maar de solver gebruikt een interne omcirkel die enkel vernieuwd wordt als het nodig is.
Bovendien heeft de solver extra informatie die de oplossing niet heeft, waardoor deze omcirkel efficiënter berekend kan worden.
Zie \autoref{sec:shell} voor meer uitleg hierover.

In de implementatie ziet de code van de solver er als volgt uit (vereenvoudigde versie):

\begin{lstlisting}
List<Circle> circlesToPack; |\label{code:start-vars}|
Queue<Hole> holes;
List<Location> shell;
Location enclosingCircle;

Solution solution; |\label{code:end-vars}|

void solve() { |\label{code:start-solve}|
	init();
	packFirstThree();
	
	while(!circlesToPack.isEmpty()) { |\label{code:best-fit-loop}|
		boolean ok = bestFitStep();
		if (!ok) break;
	}
}

boolean bestFitStep() {
	if (circlesToPack.isEmpty()) {
		return false;
	}
	
	if(!holes.isEmpty()) {
		...
		// Probeer een cirkel in een gat te plaatsen
		...
		return true;
	}
	else if (!shell.isEmpty()) {
		...
		// Probeer een cirkel op de shell te plaatsen
		...
		return true;
	}
}
\end{lstlisting}

De solver bevat alle nodige informatie over de shell en holes, als ook de cirkels die nog geplaatst moeten worden en de huidige tussen-oplossing (\autoref{code:start-vars} tot \autoref{code:end-vars}).
Om een probleem op te lossen wordt de solve methode (\autoref{code:start-solve}) aangeroepen.
Deze initialiseert eerst alle nodige variabelen, doet dan de initiële packing (meer hierover in \autoref{sec:initialisatie}) en voert dan best-fit-stappen uit tot een oplossing bereikt is (vanaf \autoref{code:best-fit-loop}).

De best-fit solver implementatie uit deze thesis kan stap voor stap de oplossing genereren en tussentijdse oplossingen visualiseren.
Het is dus niet nodig een packing volledig te maken, het kan zeer nuttig zijn tussentijdse oplossingen te zien, zeker bij het debuggen of implementeren van nieuwe functionaliteit.

\section{Initialisatie} \label{sec:initialisatie}

Zoals eerder gezegd bouwt het algoritme steeds verder op een packing uit de vorige stap.
Hierdoor is het dus nodig om een initiële packing te maken van een aantal cirkels waarop de volgende stappen kunnen verder bouwen.
Deze initiële packing is de optimale packing van de drie grootste cirkels in het probleem.
Deze drie cirkels worden zo geplaatst dat ze alle drie aan elkaar raken, zoals getoond in \autoref{fig:initialisatie}.
De licht blauwe cirkels tonen de drie eerste-geplaatste cirkels.
Meer uitleg over hoe u deze figuur kan interpreteren kan u vinden in \autoref{chap:handleiding-visualisaties}

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{initialisatie.png}
  \caption{Voorbeeld van initiële packing} \label{fig:initialisatie} 
\end{figure}

Het exacte proces om deze initiële packing te bekomen wordt verduidelijkt aan de hand van code uit de implementatie:

\begin{lstlisting}
private void packFirstThree() {
	//Initially place the two biggest circles next to eachother
	Circle first = circlesToPack.get(0); |\label{code:start-grootste-twee-plaatsen}|
	Circle second = circlesToPack.get(1);

	Vector2 firstPos = new Vector2(0, 0);
	Vector2 secondPos = new Vector2(first.getRadius() + second.getRadius(), 0); |\label{code:end-grootste-twee-plaatsen}|

	Location firstLoc = new Location(firstPos, first);
	Location secondLoc = new Location(secondPos, second);
	getSolution().add(firstLoc); |\label{code:twee-grootste-aan-sol-toevoegen}|
	getSolution().add(secondLoc);

	// Place the third biggest circle on top of the first two (assuming they are positioned clockwise)
	Circle third = circlesToPack.get(2);
	Vector2 thirdPos = Helpers.getMountPositionFor(third, firstLoc, secondLoc); |\label{code:derde-grootste-positie-berekenen}|
	Location thirdLoc = new Location(thirdPos, third);
	getSolution().add(thirdLoc);

	circlesToPack.remove(first);
	circlesToPack.remove(second);
	circlesToPack.remove(third);

	// Create first hole
	holes.add(new NHole(firstLoc, secondLoc, thirdLoc)); |\label{code:eerste-gat-maken}|
	// Create the initial shell
	// IMPORTANT: must be clock-wise
	shell.add(firstLoc); |\label{code:initiele-shell-maken}|
	shell.add(thirdLoc);
	shell.add(secondLoc);

	enclosingCircle = Location.calculateEnclosingCircle(Arrays.asList(firstLoc, secondLoc, thirdLoc));
}
\end{lstlisting}

Eerst worden de twee grootste cirkels naast elkaar geplaatst.
Vanaf \autoref{code:start-grootste-twee-plaatsen} tot \autoref{code:end-grootste-twee-plaatsen} worden eerst de twee grootste cirkels uit het probleem opgevraagd.
De lijst \textit{circlesToPack} is gesorteerd van groot naar klein, dus dit zijn de eerste twee cirkels in deze lijst.
De eerste wordt in de oorsprong geplaatst, en de tweede er tegen op de horizontale as.
Deze worden ook reeds aan de tussentijdse oplossing toegevoegd (vanaf \autoref{code:twee-grootste-aan-sol-toevoegen}).
Vervolgend wordt de positie berekend voor de derde aan de hand van een helper functie op \autoref{code:derde-grootste-positie-berekenen}.
Deze helper functie komt regelmatig terug, en wordt verduidelijkt in \autoref{sec:een-cirkel-tegen-twee-andere-plaatsen}.

In de initialisatie wordt ook het eerste gat gemaakt, gedefinieerd door de eerste drie cirkels.
Dit gat wordt toegevoegd aan de lijst van gaten in de solver op \autoref{code:eerste-gat-maken}.
Ook wordt de shell aangemaakt, vanaf \autoref{code:initiele-shell-maken}.
Deze wordt met de klok mee (gezien vanuit het centrum van de huidige packing) bij gehouden.
Verdere uitleg hierover is te vinden in \autoref{sec:shell}.

\section{Een cirkel tegen twee andere plaatsen} \label{sec:een-cirkel-tegen-twee-andere-plaatsen}

In verschillende delen van de heuristiek is het nodig om een cirkel $c_i$, met radius $r_i$, tegen twee andere cirkels te plaatsen.
Deze twee cirkels noemen we $c_g1, c_g2$, en hun radii $r_g1, r_g2$.
Het punt vinden waarop deze cirkel moet staan om beide andere cirkels te raken wordt bepaald door een eenvoudige cirkel-cirkel intersectie, tussen twee cirkels met hun middelpunt gelijk aan het middelpunt van de cirkels $c_g1$ en $c_g2$ en als radii $r_g1+r_i$ en $r_g2+r_i$:

\begin{lstlisting}
Vector2 getMountPositionFor(Circle cir, Location first, Location second) {
	double x0 = first.getPosition().getX();
	double y0 = first.getPosition().getY();
	double r0 = first.getCircle().getRadius() + cir.getRadius();

	double x1 = second.getPosition().getX();
	double y1 = second.getPosition().getY();
	double r1 = second.getCircle().getRadius() + cir.getRadius();

	// dx en dy zijn de verticale en horizontale afstand tussen de cirkel-centra.
	double dx = x1 - x0;
	double dy = y1 - y0;

	// Bepaalde de afstand tussen de centra
	//d = sqrt((dy*dy) + (dx*dx));
	double d = Math.hypot(dx, dy);

	// 'Punt 2' is het punt waar de lijn door de cirkel-intersectie punten de lijn tussen de cirkel-centra kruist
	// We berekenen hier de coordinaten x2 en y2 van dit punt

	// Bepaal eerst de afstand van tussen Punt 2 en het centrum van de eerste cirkel
	double a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d);

	// Bepaal dan de coordinaten van Punt 2.
	double x2 = x0 + (dx * a/d);
	double y2 = y0 + (dy * a/d);

	// Bepaal nu de afstand van Punt 2 naar een van de intersectie-punten
	// Het tweede intersectie-punt ligt even ver
	double h = Math.sqrt((r0*r0) - (a*a));

	// Zet deze afstand om naar een vector met de juiste richting
	double rx = -dy * (h/d);
	double ry = dx * (h/d);

	// Bepaal een van de tweede intersectie punten
	return new Vector2(x2 - rx, y2 - ry); |\label{code:cirkel-cirkel-intersectie-neg}|
}
\end{lstlisting}

In deze code wordt één van de intersectie punten bepaald.
Dit intersectie punt is steeds het negatieve punt.
Als op \autoref{code:cirkel-cirkel-intersectie-neg} $+$ gebruikt wordt in plaats van $-$ kan het tweede punt bekomen worden.
Het is ook mogelijk het andere intersectie punt te verkrijgen door de twee $location$ parameters om te wisselen.

Het bekomen punt is steeds het punt dat aan uw linker kant zou liggen indien je wandelt van het centrum van de eerste cirkel naar het centrum van de tweede cirkel.
Dit is verduidelijkt in \autoref{fig:cirkel-cirkel-intersectie}, de onderste cirkel is de eerste, de bovenste cirkel de tweede.
De pijl tussen deze cirkels geeft de \textit{wandel richting} aan.

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{cirkel-cirkel-intersectie.png}
  \caption{Verkregen intersectie punt van $getMountPositionFor$} \label{fig:cirkel-cirkel-intersectie} 
  \caption*{(Gemaakt met web.geogebra.org)}
\end{figure}

\section{Holes} \label{sec:holes}

Het eerste van de twee belangrijkste concepten van de heuristiek is \textit{holes} of \textit{gaten}.
Dit zijn plaatsen tussen andere, reeds geplaatste, cirkels waar potentieel nog een cirkel tussen kan passen.
De heuristiek zal telkens eerst deze gaten proberen op te vullen, alvorens cirkels op de shell te plaatsen.

Gaten worden gedefinieerd door exact drie cirkels in de huidige packing.
De solver houdt informatie bij voor elk gat waar mogelijk nog een cirkel in kan passen.
Bij elke stap van de solver zal er eerst gekeken worden of er nog gaten in de oplossing zijn.
Indien er nog gaten zijn zal hij deze dus eerst hier een cirkel in proberen plaatsen.
Indien het gat te klein is voor alle nog-te-plaatsen cirkels wordt dit gat simpelweg verwijderd uit de lijst van gaten in de solver.
Op deze manier weet de solver in de volgende stap dat hij daar niet meer moet proberen om een cirkel te plaatsen, en zal hij een ander gat uitproberen.
Indien er wel een cirkel in het gat past wordt deze daar in geplaatst.
Dit zal leiden tot het creëren van drie nieuwe gaten, zoals getoond in \autoref{fig:voorbeeld-gat-stap-1} en \autoref{fig:voorbeeld-gat-stap-2}.
De eerste figuur toont het gat waarin een cirkel geplaatst zal worden (de rode driehoek).
De tweede figuur toont de nieuwe packing, nadat een cirkel geplaatst is in dit gat.
Er zijn drie nieuwe kleinere gaten gemaakt, die in de volgende stappen ook zullen opgevuld worden indien mogelijk.
Het algoritme zal deze gaten ook terug proberen opvullen.
In \autoref{fig:voorbeeld-gat-stap-3} en \autoref{fig:voorbeeld-gat-stap-3alt} wordt respectievelijk de tussen-oplossing getoond voor wanneer er nog een cirkel is die klein genoeg is, en wanneer dit niet het geval is, om het onderste gat op te vullen.

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{voorbeeld-gat-stap-1.png}
  \caption{Packing voor het opvullen van een gat} \label{fig:voorbeeld-gat-stap-1} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{voorbeeld-gat-stap-2.png}
  \caption{Packing na het opvullen van een gat} \label{fig:voorbeeld-gat-stap-2} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{voorbeeld-gat-stap-3.png}
  \caption{Packing na het opvullen van een tweede gat} \label{fig:voorbeeld-gat-stap-3} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{voorbeeld-gat-stap-3alt.png}
  \caption{Packing als het opvullen van een tweede gat mislukt} \label{fig:voorbeeld-gat-stap-3alt} 
\end{figure}

\subsection{Grootste cirkel zoeken die past in een \textit{hole}} \label{sec:grootste-cirkel-zoeken-die-past-in-een-hole}

Bij het plaatsen van een cirkel in een gat wordt een zo groot mogelijke cirkel gezocht die in dit gat past.
Dit is bij wijze van spreken de best-passende cirkel, vandaar \textit{best-fit}.
Meer uitleg over hoe bepaald wordt of een cirkel past vind je in \autoref{subsec:bepalen-of-een-cirkel-past-in-hole}.
Hier wordt het proces om te vinden \textit{welke} cirkel past verder verduidelijkt.
Er wordt binair gezocht door de lijst van cirkels om te bepalen welke cirkel de grootste is die past.
Onderstaande code verduidelijkt dit proces.

\begin{lstlisting}
Location findBestFitFor(Hole hole, List<Circle> sortedBigToSmall) {
	// Probeer eerst de kleinste cirkel
	int lower = sortedBigToSmall.size() - 1; |\label{code:probeer-eerst-kleinste-in-hole}|
	Circle smallestCir = sortedBigToSmall.get(lower);
	Vector2 smallestPos = hole.tryFit(smallestCir);
	if (smallestPos == null) {
		return null;
	}

	// Probeer dan de grootste cirkel
	int upper = 0; |\label{code:probeer-dan-grootste-in-hole}|
	Circle biggestCir = sortedBigToSmall.get(upper);
	Vector2 biggestPos = hole.tryFit(biggestCir);
	if (biggestPos != null) {
		return new Location(biggestPos, biggestCir);
	}

	// Binair zoeken
	Circle cir = null;
	Vector2 pos = null;
	while (lower - upper > 1) {
		int middle = (upper + lower) / 2;
		cir = sortedBigToSmall.get(middle);
		pos = hole.tryFit(cir);

		if (pos == null) {
			upper = middle;
		}
		else {
			lower = middle;
		}
	}

	cir = sortedBigToSmall.get(lower);
	pos = hole.tryFit(cir);
	if (pos != null) {
		return new Location(pos, cir);
	}
	else {
		return null;
	}
}
\end{lstlisting}

De solver houdt de lijst van cirkels bij gesorteerd op grootte, dat is cruciaal om snel de beste-passende cirkel te vinden.
Eerst worden de grootste en kleinste cirkel uitgeprobeerd (\autoref{code:probeer-eerst-kleinste-in-hole}).
Indien de kleinste niet past zal het algoritme direct rapporteren dat dit gat te klein is.
Het gat zal dan, zoals vermeld in \autoref{sec:holes}, verwijderd worden uit de lijst van mogelijk holes.
Indien de grootste past (\autoref{code:probeer-dan-grootste-in-hole}) zal het algoritme onmiddellijk deze cirkel plaatsen in het gat.
Er zijn immers geen grotere cirkels, dus deze is de cirkel die verondersteld wordt best te passen.
Vervolgens word er een gebied bepaald in de overblijvende cirkels, waarin de best-passende cirkel zich bevind.
Initieel ligt de boven-en ondergrens van dit gebied op de uiteinden van de overblijvende cirkels.
De cirkel in de midden van dit gebied wordt dan uitgeprobeerd.
Afhangende of deze wel of niet past zal de boven-of ondergrens aangepast worden.
Dit wordt telkens herhaald tot er nog maar één cirkel over blijft.
Dit is dan de grootste cirkel die past in het gat.

\subsection{Bepalen of een cirkel past in een \textit{hole}} \label{subsec:bepalen-of-een-cirkel-past-in-hole}

Er is geen exact definitie van de grootte van een gat.
Dit is niet mogelijk omdat de cirkels die het gat bepalen niet altijd aan elkaar raken.
Het is echter wel mogelijk om te bepalen of een cirkel past.

Dit gebeurt door de cirkel die we willen testen te plaatsen in het gat.
Eerst wordt de cirkel tegen twee van de cirkels in het gat geplaatst, met een cirkel-cirkel intersectie zoals beschreven in \autoref{sec:een-cirkel-tegen-twee-andere-plaatsen}.
Deze cirkel-cirkel intersectie heeft natuurlijk altijd twee punten.
Hiervan moet er één gekozen worden.
De implementatie zorgt er voor dat de cirkels die het gat definieren telkens tegen de klok gesorteerd zijn (ten op zichte van het middelpunt van deze deze drie cirkels).
Dit maakt het mogelijk telkens het juiste punt te kiezen.
Eenmaal dit punt bepaald is word de cirkel op deze plek gezet.
Dan wordt gekeken of deze cirkel wel effectief in het gat geplaatst is, en of deze niet overlapt met de derde cirkel die het gat definieert.

\begin{lstlisting}
public Vector2 tryFit(Circle cir) {
	// Try to place circle
	Vector2 pos = Helpers.getMountPositionFor(cir, first, second);

	// Check that is inside the hole
	boolean inside = Vector2.isInsideTriableBy(first.getPosition(), second.getPosition(), third.getPosition(), pos); |\label{code:try-fit-in-triangle}|
	if (!inside) {
		return null;
	}

	// Test for overlap
	Location loc = new Location(pos, cir);
	if (third.overlaps(loc)) { |\label{code:try-fit-derde-overlap}|
		return null;
	}
	return pos;
}
\end{lstlisting}

Op \autoref{code:try-fit-in-triangle} wordt verzekerd dat het middelpunt van de cirkel in het gat ligt.
Dit voorkomt dat de geplaatste cirkel buiten het gat geplaatst wordt, en dus zeker niet kan overlappen met cirkels buiten het gat zonder ook te overlappen met één van de cirkels die het gat definiëren.
Op \autoref{code:try-fit-derde-overlap} wordt dan de overlap met de derde gat-definiërende cirkel nagekeken.
Er kan geen overlap zijn met de eerste twee, de methode $getMountPositionFor$ plaatst de cirkel zodanig dat deze de twee andere cirkels raakt, maar niet overlapt.
Indien de cirkel in het gat past, en dus alle checks doorstaat, wordt de positie voor deze cirkel terug gegeven.
De solver zal deze cirkel dan plaatsen in zijn oplossing.

Het is niet nodig om na te gaan of er overlap is met andere cirkels in de oplossing.
Als er met een andere overlap zou zijn, moet dit zijn omdat de cirkel buiten het gat geplaatst is, of er is ook overlap met één van de cirkels in het gat zelf.
Dit zorgt er voor dat er zeer weinig overlap-checks gedaan moeten worden, wat het algoritme zeer snel maakt.

\section{Shell} \label{sec:shell}

De \textit{shell} of \textit{schil} is het tweede van de belangrijkste concepten van de heuristiek.
Dit is de buitenste laag van cirkels in een (tussen-)oplossing van de solver.
Deze wordt in de implementatie simpelweg bijgehouden als een geordende lijst van cirkels.
Cirkels die naast elkaar staan in de lijst, grenzen ook aan elkaar in de shell.
De cirkels in deze laag zijn met de klok mee gesorteerd, ten opzichte van het middelpunt van de omcirkel.
De eerste en laatste cirkel in de lijst grenzen ook aan elkaar in de shell.

De heuristiek voorgesteld in deze thesis probeert steeds eerst alle gaten op te vullen.
Maar wanneer er geen cirkels meer over zijn die klein genoeg zijn om te passen in gaten, word er een cirkel op de shell geplaatst.
Op de shell worden alle posities tegen twee cirkels van de shell overwogen.
Dit is een goede heuristiek voor de optimale positie, beperkt het aantal mogelijke posities voor de geplaatste cirkel enorm en maakt het algoritme dus zeer snel (zie \autoref{chap:resultaten} voor een vergelijking in snelheid).
Er wordt steeds een cirkel zo dicht mogelijk bij het centrum van de huidige tussen-oplossing geplaatst.
Dit om het uitbreiden van de omcirkel zo min mogelijk te houden.

Eerst worden twee cirkels gekozen waartegen de nieuwe geplaatst zal worden.
Hiervoor wordt gekeken naar het middelpunt tussen alle cirkels die naast elkaar staan op de shell.
De twee cirkels waarvoor het middelpunt het dichtst bij het centrum van de huidige omcirkel ligt worden gekozen als kandidaten om de derde cirkel tegen te plaatsen.
Dan wordt er gezocht naar een zo groot mogelijke cirkel die daar past op de shell.
Indien geen enkele cirkel past wordt één van de twee kandidaat cirkels verwijderd uit de shell.
Welke verwijderd wordt verduidelijkt in \autoref{sec:bepalen-of-een-cirkel-past-op-de-shell}.
Dit zorgt er voor dat de shell verandert en \textit{groeit} naar buiten.
In de volgende stap van het algoritme zal dan ook een andere positie voor een cirkel uitgeprobeerd worden.
Indien er wel een cirkel past wordt deze toegevoegd aan de shell, en geeft deze aanleiding tot een nieuw gat.
Dit gat zal vervolgens opgevuld worden indien mogelijk, zoals beschreven in \autoref{sec:holes}.
Op \autoref{fig:plaats-op-shell-simpel} wordt getoond hoe de packing verandert wanneer een cirkel geplaatst wordt op de shell.
Eerst wordt een packing zonder gaten getoond en vervolgens de packing nadat een cirkel op de shell geplaatst is.
Hierop is duidelijk te zien hoe de shell aangepast is geweest, en deze plaatsing geleid heeft tot een nieuw gat.
Zoals eerder gezegd is het mogelijk dat op een positie op de shell de grootste cirkel niet past.
Dit wordt geïllustreerd in \autoref{fig:plaats-op-shell-kleiner}.
Het is ook mogelijk dat geen enkele cirkel nog past op de shell, zoals getoond in \autoref{fig:plaats-op-shell-geen-enkele-past}.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{plaats-op-shell-simpel.png}
  \caption{Het plaatsen van de grootste cirkel op de shell} \label{fig:plaats-op-shell-simpel} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{plaats-op-shell-kleiner.png}
  \caption{Het plaatsen van een kleinere cirkel op de shell} \label{fig:plaats-op-shell-kleiner} 
  \caption*{Focus: midden bovenaan}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{plaats-op-shell-geen-enkele-past.png}
  \caption{Shell aanpassen als geen enkele cirkel past} \label{fig:plaats-op-shell-geen-enkele-past} 
  \caption*{Focus: rechts onderaan}
\end{figure}

\subsection{Slim de omcirkel berekenen gebaseerd op de shell}

Bij het kiezen van de kandidaat cirkels om een cirkel tegen te plaatsen op de shell wordt gebruik gemaakt van de omcirkel van de huidige tussen-oplossing.
Zoals eerder vermeld kan voor elke (tussen-)oplossing de omcirkel berekend worden.
Dit gebeurt door een aangepaste versie van het Welz algoritme voor de omcirkel van punten beschreven in \cite{welzl1991smallest}.
De implementatie is gebaseerd op de implementatie in \cite{sunshine2008welzl}.
Het is een recursief algoritme dat in lineaire tijd de omcirkel kan berekenen.
Het idee is dat de omcirkel van een aantal cirkels (of punten) volledig gedefinieerd is door maximum drie cirkels.
Het algoritme vind deze twee of drie cirkels.

Het is eenvoudig in te zien dat deze drie cirkels aan de buitenkant van een (tussen-)oplossing zullen liggen.
Dit is ook net wat de shell is, de cirkels aan de buitenkant van een oplossing.
Het is dus mogelijk om in elke stap van de solver de omcirkel zeer efficient te berekenen.
De complexiteit is dan slechts lineair in het aantal cirkels op de shell in huidige (tussen-)oplossing, wat slechts een subset is van totaal aantal cirkels in de oplossing.
Aangezien de omcirkel regelmatig moet herberekend worden doorheen het algoritme is dit een zeer interessante optimalisatie.

\subsection{Bepalen of een cirkel past op de shell} \label{sec:bepalen-of-een-cirkel-past-op-de-shell}

Om te bepalen of een cirkel op de shell past plaatsen we de cirkel eerst tegen twee cirkels op de shell.
Dit gebeurt op de zelfde manier als het plaatsen van een cirkel tegen twee cirkels van een gat.
De exacte methode is reeds uitgelegd in \autoref{sec:een-cirkel-tegen-twee-andere-plaatsen}.
Eenmaal deze positie gekend is, wordt er nagekeken of dit niet tot overlap leidt.
Indien er overlap is is het niet mogelijk om de cirkel daar op de shell te plaatsen, en wordt er informatie terug gegeven over welke cirkel op de shell voor problemen zorgt.

Om na te gaan of er overlap is, wordt er systematisch een aantal cirkels op de shell nagekeken.
Het is niet nodig andere cirkels, die niet op de shell zitten, na te kijken voor overlap.
Een nieuwe cirkel wordt steeds op de shell geplaatst zodanig dat als er overlap zou zijn met cirkels in de oplossing, minstens één van die cirkels op de shell ligt.
Doordat ik geen exacte definitie van de shell heb, ze is enkel gedefinieerd door het algoritme dat ze opbouwt, is het niet mogelijk om hier een echt bewijs van te geven.
Uit empirische tests lijkt dit echter wel te kloppen.
Verdere bedenkingen hierbij kan u terug vinden in \autoref{chap:opmerkingen-en-verder-werk}.
Om deze overlappings-test zeer snel te kunnen uitvoeren worden eerst cirkels dicht bij nagekeken.
Er staat ook een limiet op het aantal cirkels die getest worden.
Uit tests, tot 5000 cirkels, blijkt dat drie cirkels aan elke kant van de shell nakijken genoeg is.
Voor de meeste gevallen is één cirkel nakijken genoeg, maar sommige randgevallen (wanneer meerdere kleine cirkels dicht bij elkaar staan op de shell) vragen deze extra checks.

Het aantal cirkels dat nagekeken wordt is een hyperparameter $checkRadius$ van het algoritme.
De volgende code toont hoe de overlap nagekeken wordt:

\begin{lstlisting}
for (int i = 1; i <= checkRadius; ++i) {
	int prevIndex = (firstIndex + shell.size() - i) % shell.size();
	Location prev = shell.get(prevIndex);
	if (loc.overlaps(prev)) {
		toRemove = first;
		break;
	}
	int nextIndex = (secondIndex + i) % shell.size();
	Location next = shell.get(nextIndex);
	if (loc.overlaps(next)) {
		toRemove = second;
		break;
	}
}
\end{lstlisting}

Er wordt dus om te beurt links en rechts van de huidige positie op de shell nakeken voor overlap.
Indien er overlap gevonden is, wordt bijgehouden aan welke kant van de shell dit gebeurd is.
$toRemove$ is dus uiteindelijk $first$ of $secons$, wat aan geeft of er aan de kant van de eerste cirkel, of van de tweede cirkel, overlap voorkomt.
$toRemove$ kan ook $null$ zijn indien er geen overlap is.
Deze informatie wordt dan gebruikt door de solver om te bepalen of de cirkel geplaatst kan worden ($toRemove = null$), of dat de shell aangepast moet worden.
Meer informatie hierover in \autoref{sec:een-cirkel-plaatsen-op-de-shell}

\subsection{Een cirkel plaatsen op de shell} \label{sec:een-cirkel-plaatsen-op-de-shell}

Om een cirkel te plaatsen op de shell wordt eerst de grootste cirkel is die past op de shell binair gezocht in de lijst van nog-te-plaatsen cirkels.
Dit gebeurt op analoge manier als het zoeken naar de grootste cirkel die past in een gat, zoals beschreven in \autoref{sec:grootste-cirkel-zoeken-die-past-in-een-hole}.
Indien er een cirkel gevonden wordt die past op de shell wordt de shell uitgebreid met deze cirkel.
De cirkel wordt dan tussen de cirkels, waartegen hij geplaatst is, gezet in de shell.
Dit wordt geïllustreerd in \autoref{fig:plaats-op-shell-simpel}, \autoref{fig:plaats-op-shell-kleiner}.
De gele lijn (die de shell voorstelt, zoals beschreven in \autoref{chap:handleiding-visualisaties}) wordt uitgebreid met een extra punt.
Ook zorgt dit er voor dat een nieuw gat gemaakt wordt waar mogelijk kleinere cirkels in passen.

Een laatste check die gebeurt is om na te gaan of door het plaatsen van de cirkel de shell nog juist gevormd is.
Indien een cirkel geplaatst wordt zodat de cirkels niet meer met de klok mee gesorteerd zijn, zou dit er voor kunnen zorgen dat foutieve plaatsingen voorkomen.
Om dit te voorkomen wordt de gerichte hoek tussen de geplaatste cirkel en de cirkels waartegen hij geplaatst is nagekeken.
Indien deze hoek negatief is wordt de shell hier voor aangepast.
Dit wordt getoond in \autoref{fig:plaats-op-shell-hoek}.
Het eerste deel toont de configuratie waarop een cirkel geplaatst zal worden.
Het laatste deel de uiteindelijke configuratie van de shell.
Het middelste deel toont met een zwarte lijn het deel van de shell dat verwijderd is om er voor te zorgen dat deze kloksgewijs gesorteerd blijft.
Op \autoref{fig:plaats-op-shell-hoek-fout}  wordt getoond wat er kan gebeuren als deze check niet gebeurt.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{plaats-op-shell-hoek.png}
  \caption{Een cirkel veroorzaakt een tegen-ge-klok shell} \label{fig:plaats-op-shell-hoek} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=.65\textwidth]{plaats-op-shell-hoek-fout.png}
  \caption{Mogelijke fout indien de shell niet met de klok mee gesorteerd is} \label{fig:plaats-op-shell-hoek-fout} 
\end{figure}

\section{Conclusie}

Dit hoofdstuk gaf een volledig overzicht van de nieuwe constructieve heuristiek.
Waar nodig werd het uitleg verduidelijkt met code uit de implementatie.
Er werden ook de verschillende veronderstellingen geformuleerd die gebruikt worden om het algoritme zeer snel te maken.
Zie ook \autoref{chap:opmerkingen-en-verder-werk} voor verdere bedenkingen hieromtrent.

\chapter{Resultaten} \label{chap:resultaten}

In dit hoofdstuk worden de verkregen packings vergeleken met de best gekende packings, zoals gerapporteerd op de Packomania website \cite{packomania}.
Packomania is een website die de best gekende oplossingen voor verschillende circle-packing problemen verzameld.
Deze vergelijking wordt gemaakt op zowel de verkregen radius van de omschreven cirkel, als ook de tijd nodig om tot deze packing te komen indien deze gekend is.
De nodige rekentijd voor deze algoritmen is echter niet altijd even makkelijk te vinden.
Veel van de packings op Packomania hebben geen bijkomende publicatie.
Het gebruikte algoritme en de nodige tijd om de packing te bekomen is dus niet gekend, enkel de coördinaten van de uiteindelijke packing.
De vergelijking in tijd zal dus een zeer ruwe vergelijking zijn gebaseerd op slechts enkele papers.

Ook geef ik resultaten voor packings met veel meer cirkels dan deze geraporteerd op Packomania.
Hiervoor heb ik geen andere resultaten gevonden in de literatuur om met te vergelijken.

Packomania heeft resultaten voor verschillende verdelingen van cirkels.
Deze verdelingen zijn als volgt:

\begin{itemize}
	\item $r_i=1$ (alle cirkels gelijke grootte)
	\item $r_i=i$
	\item $r_i=i^{1/2}$
	\item $r_i=i^{-1/5}$
	\item $r_i=i^{-1/2}$
	\item $r_i=i^{-2/3}$
\end{itemize}

Hierbij zijn er telkens $N$ cirkels in het probleem, en is $i \in (1,2,...,N)$.
De verhouding tussen enkele van deze verdelingen worden verduidelijk in \autoref{fig:packomania-verdelingen}.

\begin {figure}
	\centering
	\resizebox {0.8\columnwidth} {!} {
		\begin{tikzpicture}
			\begin{axis}[ xlabel=$i$, ylabel=radius, domain=1:50 ]
				\addplot[green]{x^(-1/5)};
				\addlegendentry{$x^{-1/5}$}
				
				\addplot[blue]{x^(-1/2)};
				\addlegendentry{$x^{-1/2}$}
				
				\addplot[red]{x^(-2/3)};
				\addlegendentry{$x^{-2/3}$}
			\end{axis}
		\end{tikzpicture}
	}
	\caption{Packomania verdelingen}
	\label{fig:packomania-verdelingen}
\end {figure}

\section{Packomania vergelijking}

In de tabellen in deze sectie wordt telkens het aantal cirkels in de kolom $N$ gegeven, de best gekende radius van op Packomania in kolom $Beste radius$ en de radius verkregen door mijn algoritme in kolom $Radius$.
Ook wordt het absolute verschil van mijn oplossing ten opzichte van de best gekende radius in de kolom $Vergroting$ gegeven, en de procentuele vergroting in kolom $Vergroting (\%)$.
Als laatste geef ik de rekentijd die mijn algoritme nodig had om tot deze oplossing te komen.
U zal merken dat sommige oplossingen plots meer tijd vragen, maar dit komt doordat alle tests na elkaar uitgevoerd werden, en hier de Java garbage collector wat tijd op eiste.

\subsection{Even grote cirkels}

Voor het circle-packing probleem met even grote cirkels worden de oplossingen voor $N=3$ tot $N=100$ in \autoref{table:packomania-equal} getoond.
Dit is slechts een subset van alle gekende oplossingen.
De volledige lijst van vergelijkingen voor dit probleem, meer dan 2500 vergelijkingen, kan u terug vinden op GitHub \cite{packomania-tables-github}.

\equalTable{Packomania \ensuremath{r_i=1}}{0}{98} \label{table:packomania-equal}

Gemiddeld geeft mijn algoritme een resultaat dat $1.89\%$ groter is dan de het best gekende resultaat.
Nodige tijd blijft onder 10 milliseconden tot $N=100$ (sommige boven 10 milliseconden zijn de wijten aan de garbage collector die dan begint te werken).
Tot 500 cirkels blijft de nodige rekentijd onder 100 milliseconden.
De rekentijd loopt pas op tot één seconden bij 2200 cirkels.

Zoals eerder vermeld zijn vergelijkingen in nodige rekentijd moeilijk te vinden.
In \cite{grosso2010} worden echter tijden gerapporteerd van 110 seconden voor 30 cirkels (mijn algoritme vroeg hier minder dan een milliseconden tijd), en 15311 seconden (meer dan 4 uur) voor 100 cirkels (mijn algoritme vroeg hier 7 milliseconden).
Zij halen resultaten die zeer dicht bij de best gekende liggen (soms de beste).

Omdat mijn algoritme enkel nieuwe cirkels tegen twee reeds geplaatste cirkels plaats, hebben alle oplossingen voor dit probleem een duidelijke structuur.
Deze structuur is een zeshoekige structuur.
Dit wordt geïllustreerd in \autoref{fig:packing-even-groot-50}, \autoref{fig:packing-even-groot-500} en \autoref{fig:packing-even-groot-2000}.
//TODO Update deze afbeeldingen

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{packing-even-groot-50.png}
  \caption{Packing voor 50 even grote cirkels} \label{fig:packing-even-groot-50} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{packing-even-groot-500.png}
  \caption{Packing voor 500 even grote cirkels} \label{fig:packing-even-groot-500} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{packing-even-groot-2000.png}
  \caption{Packing voor 2000 even grote cirkels} \label{fig:packing-even-groot-2000} 
\end{figure}


\subsection{Packomania Machten}

Packomania rapporteert ook resultaten voor verschillende verdelingen met een vaste structuur: $r_i=i^X$.
Hier is X steeds een andere macht.
Deze problemen neem ik onder één noemen, de \textit{Packomania macht} problemen.

In onderstaande tabellen worden alle resultaten van deze problemen gegeven:

\powerTable{Packomania \ensuremath{r_i=i}}{0}{196}

\powerTable{Packomania \ensuremath{r_i=i^{1/2}}}{196}{292}

\powerTable{Packomania \ensuremath{r_i=i^{-1/5}}}{444}{504}

\powerTable{Packomania \ensuremath{r_i=i^{-1/2}}}{292}{388}

\powerTable{Packomania \ensuremath{r_i=i^{-2/3}}}{388}{444}


//TODO Vraag voor Patrick: Deze tabellen tonen een vergelijking alle problemen van op Packomania, behalve voor de gelijke grote cirkels aangezien dit anders meer dan 60 bladzijden voor één tabel zou zijn. De tabellen die er nu staan nemen echter ook wel wat paginas in beslag. Moet ik deze ook slechts deels tonen, of is het ok zo?

Gemiddeld geeft mijn algoritme een resultaat dat $5,61\%$ groter is dan de best gekende resultaten.
Nodige rekentijd is voor al deze problemen slechts enkele milliseconden, met enkele uitschieters die te wijten zijn aan de Java garbage collector.

Nodige rekentijd in de literatuur loopt op tot 6 uur in \cite{jors2011}, tot 7 uur in \cite{lopez2013packing} en zelfs meer dan een volledige dag (27 uur) in \cite{zeng2016iterated}, voor slechts 30 cirkels (dit in vergelijking met één milliseconde voor mijn algoritme).
Het snelste andere algoritme, tot zover ik weet, werd gegeven in \cite{ye2013iterated}.
Zij hadden tijden tussen 1 seconden voor 5 cirkels, en 1 uur voor 30 cirkels.
Zij hadden echter geen goed stopping-criteria, en deze tijd was dus de tijd nodig alvorens ze hun beste oplossing vonden, maar hun algoritme bleef ongeacht meer dan 2,5 uur zoeken.

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{packing-neg1div2-1000.png}
  \caption{Packing voor 1000 cirkels met verdeling $r_i=i^{-1/2}$} \label{fig:packing-neg1div2-1000} 
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.65\textwidth]{packing-neg1div5-1000.png}
  \caption{Packing voor 1000 cirkels met verdeling $r_i=i^{-1/5}$} \label{fig:packing-neg1div5-1000} 
\end{figure}

//TODO: Meer afbeeldingen van machten packings

\subsection{Packomania Benchmark}

\benchmarkTable{Packomania Benchmark Instances}{0}{1000}

\section{Grotere aantallen cirkels}





\chapter{Opmerkingen en verder werk} \label{chap:opmerkingen-en-verder-werk}

// TODO Bespreking van verbeteringen/andere mogelijke strategieën/losse eindjes

// TODO Bedenkingen bij veronderstellingen in het algorime, deze lijken te kloppen maar hebben geen bewijs.

// TODO Problemen met hole bespreken

// TODO verder uitweiden over clockwise/counterclockwise en dat hier tussen gewisseld wordt voor een stabielere fout?

\chapter{Conclusie} \label{chap:conclusie}



// TODO ALGEMEEN: Minder informele termen? Omcirkel->omschreven cirkel

// TODO ALGEMEEN: Voeg echte definities toe, bv bij Hole echt een hoofding "Definitie" en dan het gat definieren. Ook voor shell, omcirkel.

\newpage

\begin{appendices}

\end{appendices}

\newpage

\bibliography{thesis}
\bibliographystyle{plain}

\newpage

% ----------------------- Achterblad ------------------------------
% Vergeet niet de tekst aan te passen:
% - Afdeling
% - Adres van de afdeling
% - Telefoon en faxnummer
% -----------------------------------------------------------------
\thispagestyle{empty}
\sffamily
%
\begin{textblock}{191}(113,-11)
{\color{blueline}\rule{160pt}{5.5pt}}
\end{textblock}
%
\begin{textblock}{191}(168,-11)
{\color{blueline}\rule{5.5pt}{59pt}}
\end{textblock}
%
\begin{textblock}{183}(-24,-11)
\textblockcolour{}
\flushright
\fontsize{7}{7.5}\selectfont
\textbf{AFDELING}\\
Straat nr bus 0000\\
3000 LEUVEN, BELGI\"{E}\\
tel. + 32 16 00 00 00\\
fax + 32 16 00 00 00\\
www.kuleuven.be\\
\end{textblock}
%
\begin{textblock}{191}(154,-7)
\textblockcolour{}
\includegraphics*[height=16.5truemm]{sedes.png}
\end{textblock}
%
\begin{textblock}{191}(-20,235)
{\color{bluetitle}\rule{544pt}{55pt}}
\end{textblock}
\end{document}
